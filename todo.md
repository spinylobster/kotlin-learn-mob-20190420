## 順番

- mohira
- nakajima

## ToDo

- [x] テストを動かしてみる
- [x] create version object
- [x] toString()
- [x] 問題1: 文字列表現
- [x] 問題2: 等価性
- [x] 問題3: エラー、例外
- [x] 問題4: バージョンアップ
  - [x] patch version up
  - [x] minor version up
  - [x] major version up
- [x] 問題5: 大小比較
  - [x] 1.3.9 < 1.4.2
  - [x] 10.3.5 > 2.23.1
-   ヒント: 使っているプログラミング言語の大小比較メソッド、イディオムについて調べてみましょう
 
## ルール
- テストを緑にする
- リファクタリングする
- 次のテストコードを書く　→　交代

## 問題4: バージョンアップ
semver におけるバージョンアップにはルールがあります

-   下位互換性のあるバグ修正を行う場合は patch フィールドをインクリメントする (パッチバージョンアップ)
-   下位互換性のある機能追加を行う場合は minor フィールドをインクリメントし、 patch フィールドを 0 にする (マイナーバージョンアップ)
-   下位互換性を壊す変更が入る場合には(バグ修正であっても、機能追加であっても)、major フィールドをインクリメントし、 minor, および patch フィールドを 0 にする (メジャーバージョンアップ)

以上の仕様を踏まえて、上記三種類のバージョンアップ機能を設計/実装しましょう

## 問題5: 大小比較
あるバージョンを、他のバージョンと大小比較できるようにしてみましょう

-   例: バージョン 1.3.9 は バージョン 1.4.2 より小さい
-   例: バージョン 10.3.5 は バージョン 2.23.1 より大きい
-   ヒント: 使っているプログラミング言語の大小比較メソッド、イディオムについて調べてみましょう

## Kotlinの便利文法

- data class
  - equals(), hashCode() 自動実装
  - version.copy(minor = 2)
  - val (major, minor, patch) = version
- require (Kotlin Contracts)
- requireNotNull() 
    - requireのNonNull検証バージョン
- override fun toString() = "${major}.${minor}.${patch}"
- 名前付き引数, デフォルト引数
- operator fun
- when
    - `in 1..10 -> hoge` みたいな条件の範囲でいけるやつ

### 出てこなかったもの

- 拡張メソッド
- enum class, sealed class
```
sealed class Hoge() {
    data class SubmitForm(val form : Form) : Hoge()

    object Cancel: Hoge()
}

hoge.form <- compile error
when (hoge) {
    // ここで、SubmitFormって確定する→smart cast
  SubmitForm -> {
      // Smart Castが存在しない場合
      if (hoge instanceof Submitform) {
          val form = (hoge as Submitform).form
      }
      
      // SmartCastをする場合、コンパイラががSubmitForm型と解釈してくれる
      val form = hoge.form
  }
  Cancel -> ...
}

val str: String? = "hoge"
val str: String? = null
var str2 : String
str.length() <- compile error (nullかもしれないので)
if (str != null) {
  // str: String
  str.length()
  str2 = str
}

```

- リスト処理
- null safety, smart cast
- delegate property
    - lazy
    - strong map property

## リモートモブ的な話
- リモートモブでもマルチディスプレイ推奨かも
- Dockerだと遅かったやつ(切り替えたのはナイス判断！)
  - DockerのVSCodeでLive Shareを起動するとめっちゃCPU重くなった
- なんかあったらとりあえず再起動
- マルチコアを体感(同時編集可能のよい側面)
- 品評会はとてもよかった
- 誰がテスト書いて、プロダクトコード書いてというタイミングが最初取りづらかった
- いまがどういう時間なのか、というのを明示できる機能（デジタルなホワイトボードとか？）があると、結構良いのかもしれない
- ドライバーの近くでメモすると気になっちゃうかも問題(別ファイルにメモがよさげ)
- ヒント(答え)
    - なんやかんや、えびさんメッチャ書いてた(ありがたや！)
      - 反省点でもありますね(モブプロベストプラクティス本に従ってない)
- めっちゃ教え合える場だったすごい(いや、まじですごいよ)
- 記述量が減っているだけなのに、それが大きな質の変化につながった話
- 最初があんまりドライブしなかった(何も考えてなかった)
- テスト書こうと思ったら、テストが終わっている感ヤバイ
- オンラインエディタだと、みんな同時編集が出来て、こんなコードを書いてーという支持がしやすい
- ドライバーとナビゲーターの境目がちょっとあやふやになるところはあるので、決めごとは必要そう。
- マルチディスプレイは推奨。（ノートは厳しいか）
- エディタの右の欄にチャット欄、メモ欄的なの欲しい
    - ペインを分割して、 memo.md とかみたいなのでやるのがいいかも
    - Discordとかだと結構見るの忘れるよね(アプリやウィンドウ切り替えとか必要になるからね)
- 実際に動くコードを書きながら言語仕様を覚えられるのが、どういう場面で使えばいいのかも想像できて良さそう。
- 品評会良かった
- エコシステム（ライブラリの使い方、gradle）などもこのスタイルで勉強するの良さそう
- オンラインだと1ターンに1人しか発話できないので、言いたいこととかアイデアは、メモのかたちで記述するのはよい作戦
    - （中嶋）トーキングオブジェクトみたいなものが、出せるといいよね。
    - オンラインなので、非同期的に情報をアウトプット出せるのが良さそう

Kotlin Koans やってみると良いと思います！
Haskell もええで！ ←　モブプロやりたいな。 <- ダシをとっているなう
Kotlin×VSCodeをやるための環境構築をしたいけど、ちょっとうまく行ってないので、誰か教えてほしい（中嶋）
↑この会ひらいたらいいんじゃねーですか　←　なる　←　やりましょう！ <- わかる！

次回もやりたいね  SemVerじゃないやつね
あと1分!!
オンラインタイマーが、あればよかったかもね

intelljでリモートモブプロやってみたい！
https://qiita.com/jiyuujin/items/7640fd44c1cc0b9f98b1